; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes='dxil-legalize' -mtriple=dxil-pc-shadermodel6.3-library %s | FileCheck %s


define void @replace_float_memset_test() {
; CHECK-LABEL: define void @replace_float_memset_test() {
; CHECK-NEXT:    [[ACCUM_I_FLAT:%.*]] = alloca [2 x float], align 4
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[ACCUM_I_FLAT]], i32 0
; CHECK-NEXT:    store float 0.000000e+00, ptr [[GEP]], align 4
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr float, ptr [[ACCUM_I_FLAT]], i32 1
; CHECK-NEXT:    store float 0.000000e+00, ptr [[GEP1]], align 4
; CHECK-NEXT:    ret void
;
  %accum.i.flat = alloca [2 x float], align 4
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %accum.i.flat)
  call void @llvm.memset.p0.i32(ptr nonnull align 4 dereferenceable(8) %accum.i.flat, i8 0, i32 8, i1 false)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %accum.i.flat)
  ret void
}

define void @replace_half_memset_test() {
; CHECK-LABEL: define void @replace_half_memset_test() {
; CHECK-NEXT:    [[ACCUM_I_FLAT:%.*]] = alloca [2 x half], align 4
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr half, ptr [[ACCUM_I_FLAT]], i32 0
; CHECK-NEXT:    store half 0xH0000, ptr [[GEP]], align 2
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr half, ptr [[ACCUM_I_FLAT]], i32 1
; CHECK-NEXT:    store half 0xH0000, ptr [[GEP1]], align 2
; CHECK-NEXT:    ret void
;
  %accum.i.flat = alloca [2 x half], align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %accum.i.flat)
  call void @llvm.memset.p0.i32(ptr nonnull align 4 dereferenceable(8) %accum.i.flat, i8 0, i32 4, i1 false)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %accum.i.flat)
  ret void
}

define void @replace_double_memset_test() {
; CHECK-LABEL: define void @replace_double_memset_test() {
; CHECK-NEXT:    [[ACCUM_I_FLAT:%.*]] = alloca [2 x double], align 4
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr double, ptr [[ACCUM_I_FLAT]], i32 0
; CHECK-NEXT:    store double 0.000000e+00, ptr [[GEP]], align 8
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr double, ptr [[ACCUM_I_FLAT]], i32 1
; CHECK-NEXT:    store double 0.000000e+00, ptr [[GEP1]], align 8
; CHECK-NEXT:    ret void
;
  %accum.i.flat = alloca [2 x double], align 4
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %accum.i.flat)
  call void @llvm.memset.p0.i32(ptr nonnull align 4 dereferenceable(8) %accum.i.flat, i8 0, i32 16, i1 false)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %accum.i.flat)
  ret void
}

define void @replace_int16_memset_test() {
; CHECK-LABEL: define void @replace_int16_memset_test() {
; CHECK-NEXT:    [[CACHE_I:%.*]] = alloca [2 x i16], align 2
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr i16, ptr [[CACHE_I]], i32 0
; CHECK-NEXT:    store i16 0, ptr [[GEP]], align 2
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr i16, ptr [[CACHE_I]], i32 1
; CHECK-NEXT:    store i16 0, ptr [[GEP1]], align 2
; CHECK-NEXT:    ret void
;
  %cache.i = alloca [2 x i16], align 2
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %cache.i)
  call void @llvm.memset.p0.i32(ptr nonnull align 2 dereferenceable(4) %cache.i, i8 0, i32 4, i1 false)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %cache.i)
  ret void
}

define void @replace_int_memset_test() {
; CHECK-LABEL: define void @replace_int_memset_test() {
; CHECK-NEXT:    [[ACCUM_I_FLAT:%.*]] = alloca [1 x i32], align 4
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr i32, ptr [[ACCUM_I_FLAT]], i32 0
; CHECK-NEXT:    store i32 0, ptr [[GEP]], align 4
; CHECK-NEXT:    ret void
;
  %accum.i.flat = alloca [1 x i32], align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %accum.i.flat)
  call void @llvm.memset.p0.i32(ptr nonnull align 4 dereferenceable(8) %accum.i.flat, i8 0, i32 4, i1 false)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %accum.i.flat)
  ret void
}
